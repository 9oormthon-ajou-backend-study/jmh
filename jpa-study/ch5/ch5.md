### 객체와 테이블의 연관관계 차이점

객체들은 참조를 통해 서로를 바라보고 관계를 맺는다. 즉 자신의 필드에 관계를 맺고자 하는 객체가 있어야 한다.
```java
@Entity
public class Member {
    ...

    private Team team;
    
    ...
}

```
멤버라는 객체가 팀이라는 객체를 참조하기 위해서는 위와 같이 팀 객체가 필드에 있어야 가능하다.  
객체 연관관계는 단방향이라는 특징이 있는데 위 코드만 존재하며 멤버는 팀을 볼 수 있지만 팀은 멤버를 볼 수 없다. 양방향으로 서로 바라볼 수 있게 하려면 팀에도 멤버필드가 존재해야 한다. 양방향은 뒤에 더 자세히 알아보자.

테이블에서 연관관계는 심플하다. 외래키 하나로 두 테이블을 연결할 수 있고 양방향 관계이다.  

`Member` 테이블
| Column   | Data Type | Description                 |
|----------|-----------|-----------------------------|
| id       | BIGINT    | Primary Key |
| name     | VARCHAR   | 멤버 이름              |
| team_id  | BIGINT    | 팀을 참조하는 외래키|

`Team` 테이블
| Column   | Data Type | Description                 |
|----------|-----------|-----------------------------|
| id       | BIGINT    | Primary Key |
| name     | VARCHAR   | 팀의 이름|

멤버 테이블의 컬럼인 `team_id`은 외래키로 팀 테이블과 연관관계를 맺는다.

객체는 참조를 통한 단방향 연관관계이고 테이블은 외래키를 통한 양방향 연관관계이다. 이제 JPA를 이용하여 다른 두 연관관계를 매핑해줘야 한다.

### 연관관계 매핑

```java
@Entity
public class Member {
    @Id @GeneratedValue
    private Long id;
    
    private String name;
    
    @ManyToOne // 다대일 관계 매핑
    @JoinColumn(name = "team_id") // 매핑할 외래 키 설정
    private Team team;
    
    ...
}

@Entity
public class Team {

    @Id @Column(name="team_id")
    private Long id;
    
    private String name;

    ...
}
```

```java
@ManyToOne 
@JoinColumn(name = "team_id") 
private Team team;
```
어노테이션으로 팀과의 연관관계를 매핑해준다. `@ManyToOne`은 다대일관계라는 매핑 정보이고, `@JoinColumn`은 외래 키를 매핑할 때 사용한다. 멤버 테이블에서 `team_id`라는 외래 키 컬럼과 매핑한다는 의미이다.

### 연관관계 사용
```
JPA에서 엔티티를 저장할 때 연관된 엔티티는 영속 상태여야 한다.
```
현재 멤버에 팀 필드가 있기 때문에 먼저 팀을 영속 상태로 만들어 주고, `member.setTeam(team)` 멤버가 팀을 참조할 수 있도록 set해준다. 그 다음에 멤버를 영속 상태로 만들어야 한다.

조회, 수정은 특이사항이 없지만 연관된 엔티티를 삭제할 때는 주의해야한다. 연관관계를 먼저 제거하고 삭제해야하는데 외래 키 제약조건 때문이다. 데이터 베이스는 외래키의 해당하는 부모 테이블이 항상 존재해야한다.
```java
member.setTeam(null); //연관 관계 제거
em.remove(team); // 팀 삭제
```
멤버 엔티티가 팀을 참조하고 있다면 참조 무결성때문에 팀을 삭제할 수 없다. 따라서 멤버가 참조하는 것을 먼저 제거해주고 팀을 삭제해줘야한다.

### 양방향 연관관계

객체는 참조로 연관관계를 맺기때문에 기본적으로 단방향이다. 테이블처럼 양방향을 만들 수 있는데 단방향을 반대 방향으로 한번 더 설정하는 것이다.
```java
Entity
public class Team {
    ...

    @OneToMany(mappedBy = "team") // 'team' 필드를 통해 매핑됨
    private List<Member> members = new ArrayList<>();

    ...
}
```
멤버와 회원이 다대일 관계이므로 회원과 멤버는 일대다 관계이다. 따라서 `@OneToMany`어노테이션을 사용했고 컬렉션을 추가하였다. `mappedBy`는 연관관계 주인을 나타내는 속성이다. 해당 속성을 사용하지 않는 객체 즉 멤버가 이 관계에 주인이다. 그리고 속성값을 멤버객체에 있는 필드 값으로 매핑한다.

**연관관계 주인**  
연관관계 주인이라는 용어때문에 해당 객체가 부모 객체(부모 테이블)인 느낌이 있는데 그러한 개념이 아니라 단순히 외래키의 관리자를 선택한다고 생각하면 된다. 보통 테이블입장에서 보면 자식 테이블이 외래키를 갖고 있다. 따라서 자식 테이블이 외래키를 관리한다. 이 느낌을 그대로 객체로 가져오면 자식 객체가 외래키를 관리하게 되고 보통은 다대일 관계에서 다에 해당하는 쪽이다. 위 예제에서는 멤버가 외래키를 관리하기 때문에 연관관계의 주인으로 설정한 것이다.  
또한, 주인만이 데이터베이스와 매핑되고 외래 키를 등록, 수정, 삭제할 수 있다.

`정리하자면 연관관계의 주인은 외래 키가 있는 곳`

양방향 관계에서 저장할 때 주인인 곳에서 연관관계를 설정해야한다. 만약 주인이 아닌 곳인 `팀`객체를 통해 연관관계를 설정하면 아무 값도 데이터베이스에 저장되지 않는다.  
그러나 사실 객체 입장에서는 주인과 주인이 아닌 곳에서도 연관관계를 설정하는 것이 안전하기 때문에 양쪽모두 관계를 설정해주자.

연관관계인 양쪽 모두 설정해줘야 하기 때문에 귀찮기도 하고 놓칠 가능성이 있다. 편의 메서드를 만들어서 한번에 설정해주는 것이 좋다.
```java
public void setTeam(Team team){

    //기존 팀과 관계를 제거
    if(this.team != null){
        this.team.getMembers().remove(this);
    }
    this.team = team;
    team.getMembers().add(this);
}
```
한번에 연관관계를 설정하기전에 기존 팀과의 관계가 있다면 제거해주는 것이 좋다. 새로운 팀과 연관관계를 맺으면 어차피 멤버가 주인이기 때문에 데이터 베이스에는 정상적으로 반영이 된다. 그러나 영속성 컨텍스트가 아직 살아있는 상태라면 위험하다.  
team1이 이전 관계이고 team2가 바뀐 관계라고 할 때 team1과의 관계를 제거하지 않으면 team1.getMembers()를 할 때 해당하는 멤버가 반환된다. 이미 끊어진 관계이지만 자바 애플리케이션에서는 유지되고 있는 것이다. 따라서 관계를 먼저 제거해주는 것이 더 안전하다.

```
책에서 추천하는 방식은 우선 단방향으로 진행하고 반대 방향에서 객체 그래프 탐색 기능이 필요할 때 양방향으로 전환하는 것이다. 양방향 매핑은 복잡하기 때문!
```

---
#### 참고
자바 ORM 표준 JPA 프로그래밍, 김영한