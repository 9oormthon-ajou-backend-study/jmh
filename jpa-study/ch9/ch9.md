## 값 타입

JPA에서는 데이터 타입을 크게 엔티티 타입과 값 타입으로 나눈다. 엔티티 타입은 `@Entity` 어노테이션으로 정의한 객체이다. 엔티티 타입은 지금까지 많이 배웠고 이번 장은 값 타입에 대해서 배운다.

값 타입은 또 3가지로 나눌 수 있다.
- 기본 값 타입
    - 자바 기본 타입: int, double 등 기본 타입
    - 래퍼 클래스: Integer, Long 등
    - String

- 임베디드 타입
- 컬렉션 값 타입

기본 값 타입은 그냥 자바와 같기 때문에 패쓰

### 임베디드 타입

임베디드 타입은 쉽게 설명하자면 엔티티 타입이 아니고 사용자가 직접 정의한 객체라고 이해하면 좋을 것 같다. 엔티티 안에서 공통으로 묶어서 객체로 관리하고 싶을 때 임베디드 타입을 정의하고 객체지향적으로 설계할 수 있다. 물론 테이블 매핑은 똑같이 잘 된다.

```java
@Entity
public class Member{
    ...

    @Embedded Period wokPeeriod;

    ...
}

@Embeddable
public class Period{
    
    @Column
    prviate LocalDateTime startDate;

    @Column
    prviate LocalDateTime endDate;
}
```

위와 같입 임베디드 타입을 정의하고 실제 엔티티에서 그 타입을 사용할 수 있다. 그냥 조금 더 객체 지향적으로 관리할 수 있고 테이블은 똑같이 한개만 생기고 멤버 엔티티에 임베디드 타입에 정의한 컬럼들도 생성이 되어서 멤버 테이블에서 하나로 동작한다.  
-> 개잘자는 객체 지향적으로 좀 더 좋은 설계를 할 수 있고 실제 테이블을 매핑하고 관리하는 귀찮은 것들은 JPA가 알아서 해준다는 아주 좋은 기능인 것 같다.

또한, 임베디드 타입에는 임베디드 타입을 포함할 수도 있고 다른 엔티티를 참조하여 연관관계를 매핑할 수 있다. 

`@AttributeOverrides`를 통해서 엔티티에서 해당 임베디드 타입에 정의된 매핑 정보를 오버라이딩할 수 있다. 따라서 한 엔티티에 같은 임베디드 타입을 선언해도 오버라이딩해서 실제 테이블과 매핑되는 컬럼이름을 변경하여 충돌을 방지할 수 있다.

### 값 타입의 위험성?

임베디드 타입도 결국에는 자바의 객체이다. 임베디드 타입의 인스턴스를 생성하고 엔티티에 값을 할당했다고 해보자. 그리고 다른 엔티티에는 `endDate` 필드 값을 바꾸고 할당했다고 하면 처음 엔티티에도 바뀐 값이 저장된다. 객체 인스턴스는 참조 값으로 되어 있기 때문에 새로운 인스턴스를 생성하거나 clone() 메서드로 복사를 해줘야 한다.

이러한 부작용을 막기위해 불변 객체로 만들어 주는 것이 좋다. `setter`를 막아놓거나 final 키워드를 사용해서 한 번 필드값이 할당되면 그 이후로 바꿀수 없도록 하는 것이다.

### 값 타입의 비교

객체를 실제로 만들면 자바로 똑같다. equals()와 hashCode()를 재정의해서 실제 다른 인스턴스라도 필드 값이 다 동일하면 동일한 객체라고 알려주도록 해야한다. 항상 두 메서드를 동시에 재정의하는 것이 좋다. 왜냐하면 HashSet이나 HashMap에서 키가 되는 인스턴스의 hashCode()를 호출하면 해당 인스턴스의 해쉬값을 받아와서 실제 저장위치를 정한다. hashCode()를 재정의 하지 않으면 equals()로는 동일한 인스턴스이지만 다른 해쉬값이 나와서 중복으로 저장이 된다. 따라서 항상 같이 재정의해주는 것이 좋다.

### 값 타입 컬렉션

엔티티에서 값 타입이 하나 이상이 필요한 경우가 있다. 얘를 멤버가 맡고 있는 직책이 여러개일 수 있다. 이때 값 타입 컬렉션으로 엔티티가 마치 여러개의 값을 갖고 있는 것 처럼할 수 있다. 그러나 실제로 관계형 데이터 베이스에서는 컬럼에 컬렉션을 포함할 수 없기때문에 별도의 테이블이 추가된다. 

값 타입 컬렉션의 제약사항이 있는데 만약 값 타입 컬렉션의 변경사항이 생기면 해당하는 데이터를 모두 삭제하고 다시 싹다 추가한다. 즉 컬렉션에서 하나를 삭제하고 하나를 추가한다고 하더라도 만약 컬렉션에 기존의 100개 데이터가 있었다면 싹 삭제하고 100번의 삽입 쿼리가 날라간다. 따라서 컬렉션이 많아지면 일대다 관계를 고려해야한다.
