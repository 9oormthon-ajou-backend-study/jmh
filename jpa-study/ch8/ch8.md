## 프록시

엔티티를 조회할 때 연관된 엔티티를 항상 사용하는 것이 아니다. 따라서 JPA는 연관된 엔티티를 사용할 때 데이터베이스에서 조회하는 지연로딩이라는 기능을 제공한다. 지연로딩을 제공하기위해서 프록시 객체를 사용한다. 말그대로 가짜 객체를 처음에 넣고 시작한다는 의미다.

```java
Class MemberProxy extends Member{
    Member target = null;

    public String getName(){

        if(target == null){

            //데이터 베이스 조회
            this.target = ...;
        }

        return target.getName();
    }
}
```

위 코드는 프록시 클래스 예상 코드다. 필드에 실제 엔티티 참조를 위한 변수가 있고 실제 엔티티의 메서드들을 오버라이딩하는 것처럼 되어 있다.  

순서는 다음과 같이 동작한다.  
```
getName() -> MemberProxy를 통해 getName() -> 실제 엔티티 참조값이 null이면 영속성 컨텍스트에서 조회 시도 
-> 영속성 컨텍스트에 없으면 DB 조회 후 실제 엔티티 생성 -> 다시 MemberProxy를 통해 getName()
```

모든 실제 엔티티의 메서드를 이렇게 프록시 객체를 통해서 실행하게 된다. 뭔가 AOP도 이렇게 프록시 객체를 사용해서 실제 객체의 메서드를 실행할 때 실행 전과 후에 로직을 추가하여 실행시키는게 아닐까 싶다. 예를 들어 @Transactional 이러한 어노테이션을 달고 있는 클래스나 메서드는 자동으로 엔티티 매니저를 할당받고 트랜잭션을 시작하고 커밋하는 것을 프록시 패턴을 이용한 AOP로 처리할 거 같은 느낌적인 느낌.

## 즉시 로딩과 지연 로딩

JPA에서는 연관된 엔티티를 조회할 때 2가지 기능을 제공하는데, 즉시 로딩은 연관된 엔티티들을 조인하여 한번에 조회하는 것이고, 지연 로딩은 위에서 본 것 처럼 실제로 엔티티를 사용할 때 조회해서 가져오는 방식이다.

### 즉시 로딩

즉시 로딩을 사용하려면 연관 관계 어노테이션에서 fetch 속성을 FetchType.EAGER로 지정하면 된다. 예시) `@ManytoOne(fetch = FetchType.EAGER)`  
즉시 로딩을 하게되면 내부조인이나 외부조인으로 한번에 데이터를 가져온다. 다대일인 관계를 갖고 있는 엔티티의 경우 사실 외래키를 갖고 있는 것이기 때문에 대부분, 아마 거의 null값이 아닐 것이다. 그렇기 때문에 `@JoinColumn(nullable=fasls)`를 설정하거나 `@ManytoOne(optional=false)`를 설정해주어서 JPA에게 null이 들어 갈 수 없다는 것을 알려주면 내부 조인으로 쿼리를 날리게 된다.  

외부 조인에 비해 내부 조인이 성능이 더 좋은데 간단하게 설명하면 외부 조인같은 경우는 조건이 일치하지 않는 데이터도 처리해줘야하고 또 NULL값으로 채워줘야하는 등 그냥 일을 더 많이 한다.

### 지연 로딩

지연 로딩을 사용하려면 fetch 속성을 FetchType.LAZY로 지정하면된다. 위에서 본 것 처럼 프록시 객체를 사용하여 지연 로딩을 진행한다. 지연 로딩을 사용하면 `@JoinColumn(nullable=fasls)`를 설정하거나 `@ManytoOne(optional=false)`를 설정해도 의미가 없는게 어차피 관련 엔티티가 필요할 때 해당 테이블을 조회하기 때문에 조인 쿼리가 사용되지 않는다.

이제 이 즉시 로딩과 지연 로딩을 언제 사용하는 것 인가가 사실 제일 중요할텐데, 저자는 일단은 모두 지연 로딩을 사용하고 정말 필요하고 최적화를 하고 싶을 때 즉시 로딩을 사용하라고 추천한다. 역시 최적화는 필요할 때만 하는 것이 안전한 것 같다..

## 영속성 전이: CASCADE

사실 데이터베이스에도 CASCADE가 존재한다. 예를 들어 외래 키 제약조건을 사용하여 부모와 자식 테이블이 있다면 부모가 삭제될 때 자식의 실제 테이블의 행도 같이 삭제가 된다. 이렇게 물리적으로 부모의 데이터를 삭제하면 부모를 외래 키로 참조하고 있는 자식 테이블도 같이 삭제할 수 있도록 CASCADE 조건을 걸 수 있다.

JPA에서 사용하는 CASCADE는 실제 데이터 베이스 레벨이 아니라 영속성 컨텍스트 레벨에서의 전이를 말한다. 데이터 베이스 레벨에서 실행하는 것을 JPA에게 위임하여 처리하도록 해주는 느낌...?

JPA에서 CASCADE는 부모 엔티티와 관련된 자식 엔티티까지 `영속성`을 전이 시키는 것이다. 영속성 전이는 부모 엔티티의 영속성을 자식에게 전이 시키는 것이기 때문에 일대다나 일대일 어노테이션에 사용된다. 그러나 엔티티는 사실 단방향일 경우 자식 엔티티만 부모 엔티티를 바라보고 있는 것이 바람직한 설정이기 때문에 영속성 전이를 사용하라면 양방향으로 설정하고 사용하게 된다.

기본적인 컨셉은 부모 엔티티에 자식 엔티티만 추가하여 연관 관계를 맺어주면 부모만 영속화시켜도 자식도 플러시되기 전에 영속성 전이가 이루어져서 영속화가 되고 데이터 베이스에 반영이 된다.

영속성 전이 속성에는 ALL, PERSIST, MERGE, REMOVE, REFRESH, DETACH가 있다.

## 고아 객체

부모 엔티티의 컬렉션에서 자식 엔티티의 참조만 제거하면 자식 엔티티가 자동으로 삭제 되는 기능을 제공한다. `@OneToMany(orphanRemoval=true)`를 설정하면 컬렌션에서 참조만 제거해도 자식 엔티티가 삭제 된다. 

주의 해야 할 점이 있다. 참조를 제거하면 자동으로 자식 엔티티를 삭제해주는 기능이기 때문에 해당 자식 엔티티를 다른 곳에서 참조하고 있으면 이 객체는 고아 객체가 아니기 때문에 삭제를 하지 않는다. 이러한 이유로 일대다, 일대일에서만 사용할 수 있다.

개념적으로 추가적인 기능을 사용할 수 있는데 부모 엔티티를 삭제하면 자식은 고아가 되기 때문에 자식 엔티티까지 삭제된다.

영속성 전이와 고아 객체를 통해서 엔티티 생명주기를 효율적으로 관리할 수 있다. 자식을 저장할 때 연관 관계만 추가해주면 자식 엔티티도 저장이 된고 자식을 삭제하려면 부모에서 자식 참조하는 것을 제거해주면 자식을 제거할 수 있다.
